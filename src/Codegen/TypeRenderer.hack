namespace Slack\Hack\JsonSchema\Codegen;

use namespace HH\Lib\{Str, Vec};
use type Facebook\HackCodegen\{CodegenShapeMember};

/**
 * Visitor which renders types generated by the Typing namespace to a file.
 *
 * This could live in Typing, but I decided to put it here because Typing
 * currently doesn't know anything about the HackCodegen namespace.
 */
final class TypeRenderer {
  use Factory;

  public function __construct(protected Context $ctx) {}

  protected function generateTypeNameFromParts(string ...$parts): string {
    $config = $this->ctx->getJsonSchemaCodegenConfig();
    if ($parts) {
      $parts[0] = $parts[0]
        |> Str\strip_prefix($$, $config->getTypeNamePrefix())
        |> Str\strip_suffix($$, $config->getTypeNameSuffix());
    }
    return $this->generateTypeName(Str\join($parts, '_'));
  }

  /**
   * Render the given type as the given name.
   */
  public function render(Typing\Type $type, string $type_name): void {
    // Visiting a shape causes it to be rendered to a file, so we only need to codegen
    // a type in the case of non-shapes.
    if ($type is Typing\ConcreteType && $type->getConcreteTypeName() === Typing\ConcreteTypeName::SHAPE) {
      $this->visitShape($type, $type_name);
    } else {
      $type_value = $this->visitType($type, $type_name);
      $this->ctx
        ->getFile()
        ->addBeforeType($this->ctx->getHackCodegenFactory()->codegenType($type_name)->setType($type_value));
      Typing\TypeSystem::registerAlias($type_name, $type);
    }
  }

  private function visitType(Typing\Type $type, string $type_name): string {
    if ($type is Typing\OptionalType) {
      return $this->visitOptionalType($type, $type_name);
    } else if ($type is Typing\TypeAlias) {
      return $this->visitTypeAlias($type);
    } else {
      $type as Typing\ConcreteType;
      return $this->visitConcreteType($type, $type_name);
    }
  }

  private function visitConcreteType(Typing\ConcreteType $type, string $type_name): string {
    if ($type->getConcreteTypeName() === Typing\ConcreteTypeName::SHAPE) {
      return $this->visitShape($type, $type_name);
    } else {
      $codegen_value = (string)$type->getConcreteTypeName();
      $generics = $type->getGenerics();
      if ($generics) {
        $codegen_value = Str\format(
          '%s<%s>',
          $codegen_value,
          Str\join(
            Vec\map_with_key($generics, ($i, $generic) ==> {
              $generic_type_name = $this->generateTypeNameFromParts($type_name, 'generic', (string)$i);
              return $this->visitType($generic, $generic_type_name);
            }),
            ', ',
          ),
        );
      }
      return $codegen_value;
    }
  }

  private function visitOptionalType(Typing\OptionalType $type, string $type_name): string {
    // Visit the inner type and then generate a type like '?<inner type>'
    $codegen_type = $this->visitType($type->getType(), $this->generateTypeNameFromParts($type_name, 'nonnull'));
    switch ($codegen_type) {
      case Typing\ConcreteTypeName::NONNULL:
        return 'mixed';
      case Typing\ConcreteTypeName::NOTHING:
        return 'null';
      default:
        return '?'.$codegen_type;
    }
  }

  private function visitShape(Typing\ConcreteType $type, string $type_name): string {
    $shape_members = vec[];
    foreach ($type->getShapeFields() as $field_name => $field) {
      $field_type_name = $this->generateTypeNameFromParts($type_name, $field_name, 'field');
      $field_type_name = $this->visitType($field['type'], $field_type_name);
      $shape_member = new CodegenShapeMember($field_name, $field_type_name);
      $shape_member->setIsOptional(!Shapes::idx($field, 'required', false));
      $shape_members[] = $shape_member;
    }
    $this->ctx->getFile()->addBeforeType(
      $this->ctx
        ->getHackCodegenFactory()
        ->codegenType($type_name)
        ->setShape(
          $this->ctx
            ->getHackCodegenFactory()
            ->codegenShape(...$shape_members)
            ->setAllowsSubtyping(!$type->isClosedShape()),
        ),
    );
    Typing\TypeSystem::registerAlias($type_name, $type);
    return $type_name;
  }

  private function visitTypeAlias(Typing\TypeAlias $type): string {
    return $type->getName();
  }
}